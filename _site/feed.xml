<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-06-24T12:17:16+02:00</updated><id>/feed.xml</id><title type="html">Davide Gessa @dakk</title><subtitle>That's me, Davide Gessa. I'm a software developer, computer scientist and sailor from Sardinia, Italy.</subtitle><entry><title type="html">Favorite dev quote</title><link href="/random/2020/06/24/favorite_quote.html" rel="alternate" type="text/html" title="Favorite dev quote" /><published>2020-06-24T11:59:28+02:00</published><updated>2020-06-24T11:59:28+02:00</updated><id>/random/2020/06/24/favorite_quote</id><content type="html" xml:base="/random/2020/06/24/favorite_quote.html">&lt;blockquote&gt;
  &lt;p&gt;Documentation is like sex: when it is good, it is very, very good; and when it is bad, it is better than nothing&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="random" /><summary type="html">Documentation is like sex: when it is good, it is very, very good; and when it is bad, it is better than nothing</summary></entry><entry><title type="html">New blog</title><link href="/random/2020/06/24/new_blog.html" rel="alternate" type="text/html" title="New blog" /><published>2020-06-24T10:59:28+02:00</published><updated>2020-06-24T10:59:28+02:00</updated><id>/random/2020/06/24/new_blog</id><content type="html" xml:base="/random/2020/06/24/new_blog.html">&lt;p&gt;This is my new blog, based on jekyll. I’ll soon import old posts from &lt;a href=&quot;https://davidegessa.wordpress.com&quot;&gt;my old blog&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="random" /><summary type="html">This is my new blog, based on jekyll. I’ll soon import old posts from my old blog.</summary></entry><entry><title type="html">Dices provably fair - Nonce overflow vulnerability</title><link href="/bitcoin/2015/02/26/dice_nonce_overflow.html" rel="alternate" type="text/html" title="Dices provably fair - Nonce overflow vulnerability" /><published>2015-02-26T23:00:01+01:00</published><updated>2015-02-26T23:00:01+01:00</updated><id>/bitcoin/2015/02/26/dice_nonce_overflow</id><content type="html" xml:base="/bitcoin/2015/02/26/dice_nonce_overflow.html">&lt;p&gt;Most of bitcoin dice software use a system to prove the fair play of the server for each bet. Most of them implement this mechanism using two seed (server seed and client seed) combined with a session nonce in the aim to provide a fair random number for each bet and usually this nonce is initialized to 0 after each seed change.&lt;/p&gt;

&lt;p&gt;But, what if this nonce is stored in an unsigned integer variable (32bit in 32bit systems, 2³² values)? Theorically after 2³²-1 bets, the nonce goes in overflow and return to 0.&lt;/p&gt;

&lt;p&gt;Saving each bet roll for every play in the first 2³²-1 window, will provide a map function:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f: n → roll . (n &amp;lt; 2³²)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;that could be used to declare a function g(m) that predicts every future roll:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g (m) = f (m % 2³²)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A simple fix for this problem is to regenerate the server seed and reset the nonce after 2³² bets.&lt;/p&gt;</content><author><name></name></author><category term="bitcoin" /><summary type="html">Most of bitcoin dice software use a system to prove the fair play of the server for each bet. Most of them implement this mechanism using two seed (server seed and client seed) combined with a session nonce in the aim to provide a fair random number for each bet and usually this nonce is initialized to 0 after each seed change.</summary></entry><entry><title type="html">Apache2: redirect different domains to subfolder</title><link href="/sys/2014/05/04/apache2_subfolder_redirect.html" rel="alternate" type="text/html" title="Apache2: redirect different domains to subfolder" /><published>2014-05-04T00:00:01+02:00</published><updated>2014-05-04T00:00:01+02:00</updated><id>/sys/2014/05/04/apache2_subfolder_redirect</id><content type="html" xml:base="/sys/2014/05/04/apache2_subfolder_redirect.html">&lt;p&gt;In the aim to merge two of my server on digitalocean, today I tried to write a mod_rewrite rule to redirect a secondary domain to a subfolder. After one hour, I found that I can do that with a VirtualHosts.&lt;/p&gt;

&lt;p&gt;Just edit the file /etc/apache2/sites-available/default and add a rule for each domain at the end of file:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
ServerName http://www.domain.org
DocumentRoot /var/www/vhosts/domain.org/www
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s easy, if you know.&lt;/p&gt;</content><author><name></name></author><category term="sys" /><summary type="html">In the aim to merge two of my server on digitalocean, today I tried to write a mod_rewrite rule to redirect a secondary domain to a subfolder. After one hour, I found that I can do that with a VirtualHosts.</summary></entry><entry><title type="html">MineML: F# miner</title><link href="/bitcoin/2013/08/28/mineml_miner.html" rel="alternate" type="text/html" title="MineML: F# miner" /><published>2013-08-28T10:59:28+02:00</published><updated>2013-08-28T10:59:28+02:00</updated><id>/bitcoin/2013/08/28/mineml_miner</id><content type="html" xml:base="/bitcoin/2013/08/28/mineml_miner.html">&lt;p&gt;MineML is a multithread CPU based bitcoin miner written in F#. At the moment it’s a slow implementation, but the class structure offers the possibility to implement different type of MinerThread using different processing methods (opencl, cuda, or sha256 dedicated hardware).&lt;/p&gt;

&lt;p&gt;The program structure is very simple: there’s a class (Program) that reads config file and creates the Miner object; the Miner object spawns MinerThread objects. At the moment there’s only the implementation for a CPU based thread, but will be possible to implement an opencl or cuda based thread.&lt;/p&gt;

&lt;p&gt;Fork on &lt;a href=&quot;https://github.com/dakk/mineml&quot;&gt;github&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="bitcoin" /><summary type="html">MineML is a multithread CPU based bitcoin miner written in F#. At the moment it’s a slow implementation, but the class structure offers the possibility to implement different type of MinerThread using different processing methods (opencl, cuda, or sha256 dedicated hardware).</summary></entry></feed>