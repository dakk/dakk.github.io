---
layout: posts
title:  "Yallo, a new Tezos language"
date:   2020-07-07 15:00:28 +0200
categories: tezos
---

As someone noticed from the previous post, last weeks I started to write a new programming language for Tezos smart contracts. This project was initially intended as a personal exercise for studying parsers, ast and other compiler’s things, but the code just go out of hand very quickly. The joke compiler is now becoming a "real language" that I’ll continue as an hobby project [github.com/dakk/yallo-lang](https://github.com/dakk/yallo-lang).

Yallo (which stands for yet another language lo?) is essentially a functional language which integrates (a sort of) object oriented paradigm. Instead of classes, interfaces and objects, in yallo we have contracts, contract interfaces and contract instances. Here it is an exemple to show how it works.

Let’s suppose we want to create a contract that defines a new token; we first define its interface (which is not mandatory for the Token contract, but useful for other contract calling a Token contract instance):

```java
interface IToken {
    entry transfer(from: address, to: address, val: nat);
    view getBalance(ad: address): nat;
}
```

As you can see, our interface has two entrypoints: transfer allows to send tokens from an address to another, and _getBalance_ is used by another contract to retrieve the token balance of the given address.
Note that we defined getBalance as a "view", which is a syntactic sugar for entrypoints which callback to an 'a contract passed as argument.

Interfaces can also be extended, so we can create an interface IMintableToken which also has a mint entrypoint.

And now let's see an implementation for this interface, the contract (something like a class); first we declare our storage, which is composed of typed fields. Then we declare a parametrized constructor which is useful for contract deploy (we will investigate this later). And finally we declare our two entrypoints.

```java
contract Token implements IToken {
    field balances: (address, nat) big_map;
    field totalSupply: nat;
    field symbol: string;

    constructor (owner: address, supply: nat, symbol: string) {
        this.balances = [ { owner: supply } ];
        this.totalSupply = supply;
        this.symbol = symbol;
    }

    entry transfer(from: address, to: address, val: nat) {
        let a: nat = this.balances.get(from, 0n);
        let b: nat = this.balances.get(to, 0n);
        assert (a >= val);
        this.balances.update(from, a - val);
        this.balances.update(to, b + val); 
        []
    }

    view getBalance(ad: address): nat {
        this.balances.get(ad, 0n)
    }
}
```

After compiling and deploying our amazing Token contract, other yallo contracts can easily interact with it. Inside our new contract entrypoint, we call the Token getBalance using the IToken.of(address) which returns a typed contract instance of IToken; then we call getBalance passing an address and our callback.

```java
import "IToken.yallo";

const tokenContractAddress: address = @KT1ThEdxfUcWUwqsdergy3QnbCWGHSUHeHJq;

contract usingAToken {
    field bal: nat;

    entry checkBalance(a: address) {
        [IToken.of(tokenContractAddress).getBalance(a, this.checkBalanceCallback)]
    }

    entry checkBalanceCallback(b: nat) {
        this.bal = b;
        []
    }
}
```

Another powerful feature that I introduced is the ability to deploy a contract from another contract, as follows. We call the createContract passing the result of Token(…), which creates a pair composed with the code of Token, and the initial storage generated by its constructor.


```java
import "Token.yallo";

contract deployAToken {
    field tokenAddress: address;

    entry deployToken() {
        let (a: address, op: operation) = Tezos.createContract (Token(Tezos.selfAddress(), 100, "ourToken"), None, 0);
        this.tokenAddress = a;
        [op]
    }
}
```

At the moment, the compiler will feature cameligo as the only target language, but I’ll work also on a Coq compilation backend. The code and the language itself is in active development and it is not yet ready to use, but any ideas and comments are welcome.

If you liked yallo, please put a star on [github.com/dakk/yallo-lang](https://github.com/dakk/yallo-lang)