---
layout: post
title: Isometria 2D e rendering in MonoGame / Xna
date: 2013-09-04 02:38:33.000000000 +02:00
type: post
published: true
status: publish
categories:
- F#
- MonoGame
- Videogames
- XNA4
tags: []
meta:
  _edit_last: '422218'
  _publicize_pending: '1'
  _wp_old_slug: rendering-isometrico-ed-implementazione-in-monogame
author:
  login: dagide
  email: gessadavide@gmail.com
  display_name: davide
  first_name: ''
  last_name: ''
---
<p>Oggi vi andrò ad illustrare come strutturare un possibile sistema di coordinate in un videogame con visualizzazione isometrica 2d (per intenderci, qualcosa di simile all'immagine successiva). Ha senso parlare ancora di 2D e di rendering isometrico? Il 2D esiste e resiste? Non ne ho idea, ma resta il fatto che la roba vecchia è sempre meglio, siamo tutti un pò nostalgici. Ed inoltre uno dei miei giochi preferiti utilizza questo tipo di visualizzazione (<a href="https://www.google.it/search?q=roller+coaster+tycoon+1&amp;tbm=isch&amp;tbo=u&amp;source=univ&amp;sa=X&amp;ei=3ZEmUoDkPMKl0AXHp4GQDA&amp;ved=0CDIQsAQ&amp;biw=1366&amp;bih=604">RollerCoasterTycoon</a>).</p>
<p><a href="http://davidegessa.files.wordpress.com/2013/09/iso.png"><img class="aligncenter" alt="TileMap" src="{{ site.baseurl }}/assets/iso.png?w=519" width="519" height="389" /></a></p>
<p><!--more--></p>
<p><strong>Coordinate</strong></p>
<p>Le "mappe" in questa tipologia di giochi, sono costituite da una griglia (o array quadrato) di immagini isometriche (dette anche tiles).</p>
<div>
<dl id="attachment_181">
<dt>
<p>[caption id="attachment_181" align="aligncenter" width="65"]<a href="http://davidegessa.files.wordpress.com/2013/09/tile_64.png"><img class="size-full wp-image-181" alt="Tile" src="{{ site.baseurl }}/assets/tile_64.png" width="65" height="33" /></a> Tile[/caption]</p>
</dt>
<dd></dd>
</dl>
</div>
<p><strong></strong>La cosa più complessa, è capire in che modo vengono gestite le coordinate di rendering, rispetto a quelle dell'array. Per capirlo velocemente basta guardare la seguente immagine:</p>
<p>[caption id="attachment_182" align="aligncenter" width="300"]<a href="http://davidegessa.files.wordpress.com/2013/09/figure22.png"><img class="size-medium wp-image-182" alt="Coordinate Tile" src="{{ site.baseurl }}/assets/figure22.png?w=300" width="300" height="167" /></a> Coordinate Tile[/caption]</p>
<p>Intuitivamente notate che le coordinate (x,y) nell'array (riportate nelle celle), vengono riscritte durante il rendering in questo modo (<em>tileSize</em> = larghezza di un singolo tile, <em>(x,y)</em> = cella nell'array):</p>
<p style="text-align:center;"><code>(x,y) -&gt; ((x + y) * tileSize / 2, (x - y) * tileSize / 4)</code></p>
<p style="text-align:left;"><strong>Rendering dei Tile</strong></p>
<p style="text-align:left;">Un altro fatto tedioso, è l'ordine in cui devono essere disegnati i Tiles sullo schermo per evitare sovrapposizioni; bisogna disegnare per primo il tile all'estremo superiore (nel disegno precedente quindi la cella <em>(0,7)</em>, poi si passa alla fila successiva, e così via. In alcuni articoli che ho trovato in rete vengono proposti complessi algoritmi iterativi, o riordinamenti dell'array dei Tile; la mia soluzione utilizza una semplice funzione ricorsiva:</p>
<p>[code language="fsharp"]<br />
    member this.Draw (indexX, indexY, startX, startY, tileSize) =<br />
        // dir = 0 -&gt; sin, 1 -&gt; des, 2 -&gt; sindes<br />
        let rec drawLoop x y dir =<br />
            if x &lt; 0 || y &lt; 0 || x &gt;= this.Width || y &gt;= this.Height then ()<br />
            else<br />
                let nx = startX + (x + y) * tileSize / 2<br />
                let ny = startY + (x - y) * tileSize / 4<br />
                this.Cells.[y * this.Width + x].Draw (nx, ny, tileSize)</p>
<p>                if dir &gt; 0 then  drawLoop (x+1) (y) 1<br />
                if dir &lt;&gt; 1 then drawLoop (x) (y-1) 2<br />
                ()</p>
<p>        drawLoop 0 (this.Height - 1) 2<br />
[/code]</p>
<p>L'idea di base è, partendo dal tile più in alto, renderizzare il tile alla posizione corrente <em>(x,y)</em>, dopodichè richiamare la funzione drawLoop sulla cella in basso a destra ed in basso a sinistra. La cella in basso a sinistra a sua volta disegna se stessa e di nuovo richiama drawLoop per entrambe le direzioni; la cella in basso a destra invece, disegna se stessa e richiama drawLoop solo per la cella in basso a destra: ovviamente potete fare anche il contrario.</p>
<p style="text-align:left;"><strong>Classi</strong></p>
<p style="text-align:left;">Per quanto riguarda l'implementazione. la soluzione più ovvia è realizzare una classe <em>TileMap</em> contenente l'array delle celle (<em>MapCell</em>) che costituiscono la mappa. Entrambe le classi presentano un metodo <em>Draw()</em>: la vostra implementazione di <em>Game::Draw() </em>richia <em>TileMap::Draw()</em> che a sua volta chiamerà <em>MapCell.Draw()</em> per ogni cella della mappa.</p>
<p>Vi allego il sorgente completo in un unico file: https://gist.github.com/dakk/6432134</p>
<p><em>Ringrazio Paul Firth per le immagini, che ho felicemente preso dal <a href="http://www.wildbunny.co.uk/blog/2011/03/27/isometric-coordinate-systems-the-modern-way/">suo articolo</a>.</em></p>
